Subject: [PATCH] add proof of work auth middleware
---
Index: pkg/config/dynamic/middlewares.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/config/dynamic/middlewares.go b/pkg/config/dynamic/middlewares.go
--- a/pkg/config/dynamic/middlewares.go	(revision 75790e0ab8bd0dcf510e11d4e9c81c4c6f0c766c)
+++ b/pkg/config/dynamic/middlewares.go	(date 1710786915215)
@@ -28,6 +28,7 @@
 	BasicAuth         *BasicAuth         `json:"basicAuth,omitempty" toml:"basicAuth,omitempty" yaml:"basicAuth,omitempty" export:"true"`
 	DigestAuth        *DigestAuth        `json:"digestAuth,omitempty" toml:"digestAuth,omitempty" yaml:"digestAuth,omitempty" export:"true"`
 	ForwardAuth       *ForwardAuth       `json:"forwardAuth,omitempty" toml:"forwardAuth,omitempty" yaml:"forwardAuth,omitempty" export:"true"`
+	ProofOfWorkAuth   *ProofOfWorkAuth   `json:"proofOfWorkAuth,omitempty" toml:"proofOfWorkAuth,omitempty" yaml:"proofOfWorkAuth,omitempty" export:"true"`
 	InFlightReq       *InFlightReq       `json:"inFlightReq,omitempty" toml:"inFlightReq,omitempty" yaml:"inFlightReq,omitempty" export:"true"`
 	Buffering         *Buffering         `json:"buffering,omitempty" toml:"buffering,omitempty" yaml:"buffering,omitempty" export:"true"`
 	CircuitBreaker    *CircuitBreaker    `json:"circuitBreaker,omitempty" toml:"circuitBreaker,omitempty" yaml:"circuitBreaker,omitempty" export:"true"`
@@ -196,6 +197,15 @@
 	Query string `json:"query,omitempty" toml:"query,omitempty" yaml:"query,omitempty" export:"true"`
 }
 
+// +k8s:deepcopy-gen=true
+
+type ProofOfWorkAuth struct {
+	Difficulty   int    `json:"difficulty,omitempty" toml:"difficulty,omitempty" yaml:"difficulty,omitempty" export:"true"`
+	RemoveHeader bool   `json:"removeHeader,omitempty" toml:"removeHeader,omitempty" yaml:"removeHeader,omitempty" export:"true"`
+	Secret       string `json:"secret,omitempty" toml:"secret,omitempty" yaml:"secret,omitempty" export:"true"`
+	ProblemBits  int    `json:"problemBits,omitempty" toml:"problemBits,omitempty" yaml:"problemBits,omitempty" export:"true"`
+}
+
 // +k8s:deepcopy-gen=true
 
 // ForwardAuth holds the forward auth middleware configuration.
Index: pkg/config/dynamic/zz_generated.deepcopy.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/config/dynamic/zz_generated.deepcopy.go b/pkg/config/dynamic/zz_generated.deepcopy.go
--- a/pkg/config/dynamic/zz_generated.deepcopy.go	(revision 75790e0ab8bd0dcf510e11d4e9c81c4c6f0c766c)
+++ b/pkg/config/dynamic/zz_generated.deepcopy.go	(date 1710786915216)
@@ -306,6 +306,12 @@
 	return out
 }
 
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *ProofOfWorkAuth) DeepCopyInto(out *ProofOfWorkAuth) {
+	*out = *in
+	return
+}
+
 // DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
 func (in *ForwardAuth) DeepCopyInto(out *ForwardAuth) {
 	*out = *in
@@ -724,6 +730,11 @@
 		in, out := &in.DigestAuth, &out.DigestAuth
 		*out = new(DigestAuth)
 		(*in).DeepCopyInto(*out)
+	}
+	if in.ProofOfWorkAuth != nil {
+		in, out := &in.ProofOfWorkAuth, &out.ProofOfWorkAuth
+		*out = new(ProofOfWorkAuth)
+		(*in).DeepCopyInto(*out)
 	}
 	if in.ForwardAuth != nil {
 		in, out := &in.ForwardAuth, &out.ForwardAuth
Index: pkg/server/middleware/middlewares.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/server/middleware/middlewares.go b/pkg/server/middleware/middlewares.go
--- a/pkg/server/middleware/middlewares.go	(revision 75790e0ab8bd0dcf510e11d4e9c81c4c6f0c766c)
+++ b/pkg/server/middleware/middlewares.go	(date 1710786915217)
@@ -212,6 +212,17 @@
 		}
 	}
 
+	// ProofOfWork
+	if config.ProofOfWorkAuth != nil {
+		if middleware != nil {
+			return nil, badConf
+		}
+		middleware = func(next http.Handler) (http.Handler, error) {
+			return auth.NewProofOfWork(ctx, next, *config.ProofOfWorkAuth, middlewareName)
+		}
+
+	}
+
 	// ForwardAuth
 	if config.ForwardAuth != nil {
 		if middleware != nil {
Index: pkg/middlewares/auth/pow.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/middlewares/auth/pow.html b/pkg/middlewares/auth/pow.html
new file mode 100644
--- /dev/null	(date 1710786915217)
+++ b/pkg/middlewares/auth/pow.html	(date 1710786915217)
@@ -0,0 +1,129 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>Проверка на DDoS</title>
+    <style>
+        body {
+            font-family: Arial, sans-serif;
+            background-color: #f0f0f0;
+            margin: 0;
+            padding: 0;
+            display: flex;
+            justify-content: center;
+            align-items: center;
+            height: 100vh;
+        }
+
+        h1 {
+            color: #333;
+        }
+
+        p {
+            color: #555;
+        }
+
+        #countdown {
+            list-style-type: none;
+            padding: 0;
+        }
+
+        #countdown li {
+            font-size: 2em;
+            color: #ff6347;
+        }
+    </style>
+</head>
+<body>
+<div>
+    <h1>Происходит проверка на DDoS</h1>
+    <p>Пожалуйста, подождите...</p>
+    <h2>Отчёт о проверке:</h2>
+    <ul id="countdown">
+        <li id="report">3</li>
+    </ul>
+</div>
+<script src="https://cdn.jsdelivr.net/npm/sha1-uint8array/dist/sha1-uint8array.min.js"></script>
+<script>
+    window.onload = function () {
+        function getRandomBytes(b) {
+            var ar = new Uint8Array(b);
+            var crypto = window.crypto || window.msCrypto;
+            if (crypto && crypto.getRandomValues) {
+                return crypto.getRandomValues(ar);
+            } else {
+                return function (ar) {
+                    for (var i = 0; i < ar.length; i++) {
+                        ar[i] = Math.floor(256 * Math.random());
+                    }
+                }
+            }
+        }
+
+        function toHex(x) {
+            return x.reduce(function (memo, i) {
+                return memo + ('0' + i.toString(16)).slice(-2);
+            }, '');
+        }
+
+        function doproofOfWork(problem, target, i, callback) {
+            const nonce = getRandomBytes(8)
+            const data = problem + toHex(nonce) + ":" + i;
+            const hash = SHA1.createHash().update(data).digest("hex");
+
+            if (hash.startsWith(target)) {
+                callback(nonce, i, hash)
+            } else {
+                setTimeout(function () {
+                    doproofOfWork(problem, target, i + 1, callback);
+                });
+            }
+        }
+
+        function proofOfWork(problem, difficulty) {
+            return new Promise(function (resolve, reject) {
+                const target = '0'.repeat(difficulty)
+                doproofOfWork(problem, target, 0, function (nonce, i, hash) {
+                    resolve({nonce, i, hash})
+                })
+            })
+        }
+
+        function setCookie(name, value, expDays) {
+            let date = new Date();
+            date.setTime(date.getTime() + (expDays * 24 * 60 * 60 * 1000));
+            const expires = "expires=" + date.toUTCString();
+            document.cookie = name + "=" + value + "; " + expires + "; path=/";
+        }
+
+        console.log("start {problem}:{exp}:{sig}")
+        proofOfWork("{problem}:{exp}:{sig}:", {bits}).then(function ({nonce, i, hash}) {
+            console.log("problem: {problem}")
+            console.log("exp: {exp}")
+            console.log("sig: {sig}")
+            console.log("bits: {bits}")
+            console.log("i: ", i)
+            console.log("nonce: ", toHex(nonce))
+            console.log("hash: ", hash)
+
+            setCookie("challenge", `{problem}:{exp}:{sig}:${toHex(nonce)}:${i}`)
+            window.location.reload();
+        })
+
+        var reportElement = document.getElementById('report');
+        var count = 3;
+
+        var countdown = setInterval(function () {
+            count--;
+            if (count > 0) {
+                reportElement.textContent = count;
+            } else {
+                clearInterval(countdown);
+                reportElement.textContent = 'Проверка завершена.';
+            }
+        }, 1000);
+    }
+</script>
+</body>
+</html>
Index: pkg/middlewares/auth/proof_of_work.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pkg/middlewares/auth/proof_of_work.go b/pkg/middlewares/auth/proof_of_work.go
new file mode 100644
--- /dev/null	(date 1710786915217)
+++ b/pkg/middlewares/auth/proof_of_work.go	(date 1710786915217)
@@ -0,0 +1,213 @@
+package auth
+
+import (
+	"bytes"
+	"context"
+	"crypto/hmac"
+	"crypto/rand"
+	"crypto/sha1"
+	"crypto/sha256"
+	"encoding/hex"
+	"fmt"
+	"hash"
+	"io"
+	"net/http"
+	"strconv"
+	"strings"
+	"time"
+
+	_ "embed"
+
+	"github.com/traefik/traefik/v2/pkg/config/dynamic"
+	"github.com/traefik/traefik/v2/pkg/log"
+	"github.com/traefik/traefik/v2/pkg/middlewares"
+	"github.com/traefik/traefik/v2/pkg/tracing"
+)
+
+const (
+	powTypeName = "proofofworkauth"
+
+	// Each hex character takes 4 bits
+	bitsPerHexChar int = 4
+	// ASCII code for number zero
+	zero rune = 48
+
+	timeExpFormat = "020106150405"
+)
+
+//go:embed pow.html
+var challengePage []byte
+
+type proofOfWorkAuth struct {
+	next         http.Handler
+	name         string
+	removeHeader bool
+	difficulty   int
+	problemBits  int
+	secret       []byte
+
+	algProblem func() hash.Hash
+	algVerify  func() hash.Hash
+}
+
+func NewProofOfWork(ctx context.Context, next http.Handler, config dynamic.ProofOfWorkAuth, name string) (http.Handler, error) {
+	if config.Secret == "" {
+		return nil, fmt.Errorf("error secret must be set", config.Secret)
+	}
+
+	pow := &proofOfWorkAuth{
+		name: name,
+		next: next,
+		// TODO: Add check must be more then 0
+		difficulty: config.Difficulty,
+		// TODO: Add check must be more then 0
+		problemBits:  config.ProblemBits,
+		secret:       []byte(config.Secret),
+		removeHeader: config.RemoveHeader,
+
+		algProblem: sha1.New,
+		algVerify:  sha256.New,
+	}
+
+	return pow, nil
+}
+
+func acceptableHeader(hash string, char rune, bits int) bool {
+	wantZeros := bits / bitsPerHexChar
+	for _, val := range hash[:wantZeros] {
+		if val != char {
+			return false
+		}
+	}
+	return true
+}
+
+func (p *proofOfWorkAuth) verifyChallengeCookie(req *http.Request) bool {
+	logger := log.FromContext(middlewares.GetLoggerCtx(req.Context(), p.name, powTypeName))
+
+	challengeCookie, err := req.Cookie("challenge")
+	if err != nil {
+		return false
+	}
+
+	// "problem:hmac:exp:nonce:count"
+	challengeParts := strings.Split(challengeCookie.Value, ":")
+	if len(challengeParts) != 5 {
+		logger.Debug("Incorrect challenge")
+		tracing.SetErrorWithEvent(req, "Incorrect challenge")
+
+		return false
+	}
+
+	hashesProblem := p.algProblem()
+	io.WriteString(hashesProblem, challengeCookie.Value)
+	sumProblem := hashesProblem.Sum(nil)
+
+	// TODO: optimize performance
+	if !acceptableHeader(hex.EncodeToString(sumProblem), zero, p.difficulty) {
+		logger.Debug("Challenge verify failed")
+		tracing.SetErrorWithEvent(req, "Challenge verify failed")
+
+		return false
+	}
+
+	expValue := challengeParts[1]
+
+	problemValue, err := hex.DecodeString(challengeParts[0])
+	if err != nil {
+		logger.Debug("Decode problem failed")
+		tracing.SetErrorWithEvent(req, "Decode problem failed")
+
+		return false
+	}
+
+	verifyValue, err := hex.DecodeString(challengeParts[2])
+	if err != nil {
+		logger.Debug("Decode verify failed")
+		tracing.SetErrorWithEvent(req, "Decode verify failed")
+
+		return false
+	}
+
+	verifyHashes := hmac.New(p.algVerify, p.secret)
+	verifyHashes.Write(problemValue)
+	io.WriteString(verifyHashes, expValue)
+
+	if !hmac.Equal(verifyHashes.Sum(nil), verifyValue) {
+		logger.Debug("Verify challenge signature failed")
+		tracing.SetErrorWithEvent(req, "Verify challenge signature failed")
+
+		return false
+	}
+
+	expTime, err := time.Parse(timeExpFormat, expValue)
+	if err != nil {
+		logger.Debug("Decode exp time failed")
+		tracing.SetErrorWithEvent(req, "Decode exp time failed")
+
+		return false
+	}
+
+	if time.Now().After(expTime) {
+		logger.Debug("Auth token expired")
+		tracing.SetErrorWithEvent(req, "Auth token expired")
+
+		return false
+	}
+
+	return true
+}
+
+func (p *proofOfWorkAuth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {
+	logger := log.FromContext(middlewares.GetLoggerCtx(req.Context(), p.name, powTypeName))
+
+	if !p.verifyChallengeCookie(req) {
+		logger.Debug("Start authentication challenge page")
+
+		expTime := time.Now().Add(time.Hour).Format(timeExpFormat)
+
+		problem := make([]byte, p.problemBits)
+		rand.Read(problem)
+
+		verifyHashes := hmac.New(p.algVerify, p.secret)
+		verifyHashes.Write(problem)
+
+		io.WriteString(verifyHashes, expTime)
+
+		rw.WriteHeader(http.StatusOK)
+
+		challengePage = bytes.Replace(
+			challengePage,
+			[]byte("{problem}"),
+			[]byte(hex.EncodeToString(problem)),
+			-1,
+		)
+		challengePage = bytes.Replace(
+			challengePage, []byte("{exp}"),
+			[]byte(expTime),
+			-1,
+		)
+		challengePage = bytes.Replace(
+			challengePage, []byte("{sig}"),
+			[]byte(hex.EncodeToString(verifyHashes.Sum(nil))),
+			-1,
+		)
+		challengePage = bytes.Replace(
+			challengePage, []byte("{bits}"),
+			[]byte(strconv.Itoa(p.difficulty)),
+			-1,
+		)
+
+		// show challenge page
+		rw.Write(challengePage)
+		return
+	}
+
+	logger.Debug("Authentication succeeded")
+
+	if p.removeHeader {
+		logger.Debug("Removing authorization header")
+		req.Header.Del("Authorization")
+	}
+	p.next.ServeHTTP(rw, req)
+}
